pragma solidity ^0.8.12;

//import "./UserContract.sol";

contract PermissionsContract{

    enum PermissionLevel{READ, SHARE, OWNER}

    struct RecordMetadata{
        address user;
        PermissionLevel level;
        bytes smk;
        bytes encodedHash;
        address giver;
    }

    event addedPermission(address user, PermissionLevel permissionLevel, address giver);
    event removedPermission(address user, PermissionLevel permissionLevel, address giver);
    address parentContractAddress;
    address public dataOwner;

    RecordMetadata[] persmissions;
    mapping (address => uint256) indexOf;

    modifier parentOnly() {
        require(msg.sender == parentContractAddress, "the sender can only be the parent UserContract");
        _;
    }

    modifier ownerOnly(){
        require(exists(tx.origin) && persmissions[indexOf[tx.origin] - 1].level == PermissionLevel.OWNER, "The sender of the transaction must be the owner of the data");
        _;
    }

    constructor(address owner, bytes memory smk, bytes memory encodedHash) {
        parentContractAddress = msg.sender;
        dataOwner = owner;
        addPermission(owner, PermissionLevel.OWNER, smk, encodedHash);
    }

    function addPermission(address user, PermissionLevel level, bytes memory smk, bytes memory encodedHash) public {
        require(indexOf[user] == 0, "User already has permissions");
        require(isParentContract(msg.sender) || canAddPermissions(tx.origin, level), "The sender of the transaction cannot manage permissions");

        persmissions.push(RecordMetadata(user, level, smk, encodedHash, tx.origin));
        indexOf[user] = persmissions.length; 
    }

    function editPermission(address user, PermissionLevel newLevel) public ownerOnly {
        require(indexOf[user] != 0, "The user does not have permissions");
        persmissions[indexOf[user] - 1].level = newLevel;
    }

    function removePermission(address user) ownerOnly public{
        require(canShare(tx.origin), "The sender of the transaction cannot manage permissions");
        require(!isOwner(user), "Unable to remove owner's data");
        if (exists(user) && (isOwner(tx.origin) || persmissions[indexOf[user] - 1].giver == tx.origin)){
            uint256 index = indexOf[user];
            if (index != persmissions.length){
                RecordMetadata storage lastRecord = persmissions[persmissions.length - 1];
                indexOf[lastRecord.user] = index;
                persmissions[index - 1] = lastRecord;                
            }
            persmissions.pop();
            indexOf[user] = 0;
        }
    }

    function getMetadata(address user) external view returns(bytes memory smk, bytes memory encodedHash){
        require(hasAccess(tx.origin, user), "User does not have permission");
        return (persmissions[indexOf[user] - 1].smk, persmissions[indexOf[user] - 1].encodedHash);
    }

    function getFullMetadata(address user) external view returns(address recordOwner, PermissionLevel permission, bytes memory smk, bytes memory encodedHash, address giver){
        require(hasAccess(tx.origin, user), "User does not have permission");
        RecordMetadata storage record = persmissions[indexOf[user] - 1];
        return (record.user, record.level, record.smk, record.encodedHash, record.giver);
    }

    function getPermissions() external parentOnly view returns(RecordMetadata[] memory){
        return persmissions;
    }

    function size() external view returns(uint256){
        return persmissions.length;
    }

    function exists(address _address) view public returns(bool){
        return indexOf[_address] != 0;
    }

    function canAddPermissions(address sender, PermissionLevel level) internal view returns(bool){
        uint256 index = indexOf[sender];
        if (index == 0)
            return false;
        if (persmissions[index - 1].level == PermissionLevel.OWNER)
            return true;
        if (level == PermissionLevel.READ)
            return persmissions[index - 1].level == PermissionLevel.SHARE;
        return false;        
    }

    function hasAccess(address sender, address metadataOwner) public view returns(bool){
        return (isOwner(sender) || sender == metadataOwner) && exists(sender);
    }

    function canShare(address user) internal view returns(bool) {
        uint256 index = indexOf[user];
        if (index == 0)
            return false;
        return persmissions[index - 1].level == PermissionLevel.OWNER || persmissions[index - 1].level == PermissionLevel.SHARE;
    }

    function isOwner(address _address) internal view returns(bool){
        return dataOwner == _address;
    }

    function isParentContract(address _address) internal view returns(bool){
        return _address == parentContractAddress;
    }
}